# =========================================================
# üöÄ Copilot Configuration for IngenierIA Flutter Project
# =========================================================

rules:
  - Always write code, comments, and documentation in **English**.
  - Follow **Clean Architecture** structure (core/data/domain/presentation/services).
  - Follow **SOLID** principles.
  - Use **Riverpod** for state management.
  - Use **Dio** for HTTP requests to NestJS.
  - Use **Supabase Flutter SDK** for data layer.
  - Use **Drift** for local caching.
  - Always prefer reusable **Widgets** over repetitive code.
  - All file, variable, and class names must be **English**, using:
      - snake_case for files
      - camelCase for variables/functions
      - PascalCase for classes/widgets
  - Each class must include a brief doc comment.
  - Avoid business logic in Widgets (use Controllers or Providers).
  - Use **async/await** syntax only (no callbacks).
  - Apply Material 3 design with consistent typography.
  - Do not hardcode URLs, store them in a config file under `/core/config`.
  - Follow Dart's effective style guide for formatting and naming.
  - Code generation should assume Flutter 3.24+ and Dart 3+.
  - Use only null-safe code.
  - When creating folders or modules, structure them like:
      ```
      /presentation/module_name/
        ‚î£ view/
        ‚î£ controller/
        ‚î£ widget/
        ‚îó provider/
      ```
  - Include minimal example UI for each role dashboard.
  - Include integration examples with NestJS Auth and Supabase.

defaultLanguage: "en"
style: "clean_architecture"
framework: "flutter"


# üß© IngenierIA Multi-Tenant Context

This project uses a **multi-service architecture**:
- **NestJS microservice** handles authentication, role verification, and JWT signing.
- **Supabase** acts as the multi-tenant data layer for each construction project (‚Äúobra‚Äù).
- **Flutter** is the main client consuming both.

## üîê Authentication flow
1. Login via NestJS (`/auth/login`).
2. The backend verifies credentials, fetches the corresponding `obra` and `user_uuid` from Supabase.
3. The JWT is signed with:
   ```json
   {
     "user_uuid": "<uuid from Supabase>",
     "obra_id": "<obra uuid>",
     "role": "<role name>"
   }
Flutter receives this JWT and uses it for Supabase queries.

üß± Data structure
Supabase stores:

obras (construction projects)

materiales, bitacoras, asistencias, etc.
All records include an obra_id UUID column.
RLS (Row-Level Security) policies filter data by obra_id from the JWT.

üß© Multi-tenant behavior
Each user sees data only from the obra included in their JWT.
Each obra has multiple roles:

Admin General

Admin Obra

Encargado de √Årea

Obrero

SST

Compras

RRHH

Consultor

üöß Implementation rules
All Supabase writes/queries must use obra_id and user_uuid from the JWT payload.

Never use NestJS numeric IDs in Supabase tables.

Always include Authorization: Bearer <jwt> in Supabase REST requests.

Supabase RLS will validate that the obra_id in the row matches the obra_id from the JWT.

üß∞ Flutter integration
In Flutter:

Store JWT in flutter_secure_storage.

Decode it locally to extract obra_id, user_uuid, and role.

Use those fields when creating or querying Supabase data.

Example:

dart
Copiar c√≥digo
await supabase.from('bitacoras').insert({
  'obra_id': jwt.obraId,
  'usuario_id': jwt.userUuid,
  'descripcion': 'Excavation complete',
});
